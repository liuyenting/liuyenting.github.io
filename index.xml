<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>胡謅</title>
    <link>https://liuyenting.github.io/</link>
    <description>Recent content on 胡謅</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-TW</language>
    <copyright>&amp;copy; &lt;a href=&#34;https://github.com/liuyenting&#34;&gt;Andy Liu&lt;/a&gt; 2017</copyright>
    <lastBuildDate>Sat, 02 Jan 2016 04:14:13 +0800</lastBuildDate>
    
	<atom:link href="https://liuyenting.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>啟用 GPIO 的特殊功能</title>
      <link>https://liuyenting.github.io/posts/gpio_enable_special_function/</link>
      <pubDate>Sat, 02 Jan 2016 04:14:13 +0800</pubDate>
      
      <guid>https://liuyenting.github.io/posts/gpio_enable_special_function/</guid>
      <description>MCU 的 GPIO 上面會有各式各樣的特殊功能在裡頭，像是 I2C、UART、PWM 等等，不過，要使用這些功能以前，需要先對這些 GPIO 做微調，否則腳位們依舊只會表現為平常的 GPIO。 這一陣子在使用 TI 的 TM4C123 系列的 MCU（它長在 Tiva Launchpad 上面），誠如開發版的名字，使用的函式庫叫做 TivaWare。這函式庫的使用上有利有弊其實，個人沒有很喜歡它，但先撇開這部分不提。 正在寫一個 I2C 的 wrapper，可以一個介面操控 MCU 上面的 4 個 I2C 的 I/O。不過測試時，除了第一組 I2C 模組會動，其他的一概不會傳出信號。稍微除了錯以後發現沒有把 GPIO 的多工器切換到 I2C，因此 I2C 模組的信號沒辦法輸出到外部 :p
下面以 I2C 為例：
SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C0); GPIOPinConfigure(GPIO_PB2_I2C0SCL); GPIOPinTypeI2CSCL(GPIO_PORTB_BASE, GPIO_PIN_2); GPIOPinConfigure(GPIO_PB3_I2C0SDA); GPIOPinTypeI2CSDA(GPIO_PORTB_BASE, GPIO_PIN_3);  這段程式經過了三個大步驟： 1. SysCtlPeripheralEnable 把模組的時脈來源打開。 2. GPIOPinConfigure 把該腳位前端的多工器切換到想使用的模組，以第三行為例，就是把 PB2 的多工器，切換到 I2C 模組編號 0 的 SCL。 3. GPIOPinTypeI2CSCL 對這個腳位做細部的 I/O 控制，像是 pull-up resistor 要不要使用、該腳位是輸入還是輸出⋯⋯等。</description>
    </item>
    
    <item>
      <title>Mat 轉 QImage</title>
      <link>https://liuyenting.github.io/posts/mat_to_qimage/</link>
      <pubDate>Fri, 01 Jan 2016 10:47:21 +0800</pubDate>
      
      <guid>https://liuyenting.github.io/posts/mat_to_qimage/</guid>
      <description>在嘗試把 Mat 印到 OpenGL 的元件上面時，通常會使用原生的影像元件進行操作而不再是原始的像素資料（cv::Mat）。也因為這樣，有了轉換函式的需求 :p
在 Stack Overflow 上面逛的時候，有人早就處理好了這件事情。
QImage Mat2QImage(const cv::Mat3b &amp;amp;src) { QImage dest(src.cols, src.rows, QImage::Format_ARGB32); for (int y = 0; y &amp;lt; src.rows; ++y) { const cv::Vec3b *srcrow = src[y]; QRgb *destrow = (QRgb*)dest.scanLine(y); for (int x = 0; x &amp;lt; src.cols; ++x) { destrow[x] = qRgba(srcrow[x][2], srcrow[x][1], srcrow[x][0], 255); } } return dest; }  不過討論串裡面其實有很多方法，我最後選擇了這個。
手邊在處理的影像，像素的格式是 RGB888，也就是一個像素由 24-bit 構成，三原色各佔用 8-bit 的空間。如果直接使用 QImage 的建構式創造出新的 QImage，由於 bits 排列的方式不同於 imread 在 Mat 當中的排列方式，會產生亂掉的圖像（應該直接說雜訊也可以⋯⋯）</description>
    </item>
    
  </channel>
</rss>